using UnityEngine;
namespace GwambaPrimeAdventure.Enemy
{
	[CreateAssetMenu(fileName = "Enemy Projectile", menuName = "Enemy Statistics/Projectile", order = 11)]
	internal sealed class ProjectileStatistics : ScriptableObject
	{
		[Header("Projectile Statistics")]
		[SerializeField, Tooltip("The physics of the enemy.")] private EnemyPhysics _physics;
		[SerializeField, Tooltip("The second projectile this will instantiate.")] private EnemyProjectile _secondProjectile;
		[SerializeField, Tooltip("The enemy that will be instantiate on death.")] private EnemyController _enemyOnDeath;
		[SerializeField, Tooltip("The fore mode to applied in the projectile.")] private ForceMode2D _forceMode;
		[SerializeField, Tooltip("If this projectile will use force mode to move.")] private bool _useForce;
		[SerializeField, Tooltip("If this projectile won't move.")] private bool _stayInPlace;
		[SerializeField, Tooltip("If this projectile will pursue the player endless.")] private bool _endlessPursue;
		[SerializeField, Tooltip("If this projectile will use parabolic movement.")] private bool _parabolicMovement;
		[SerializeField, Tooltip("If this peojectile will move in side ways.")] private bool _sideMovement;
		[SerializeField, Tooltip("If this projectile will move in the opposite way.")] private bool _invertSide;
		[SerializeField, Tooltip("If the rotation of this projectile will be used.")] private bool _useSelfRotation;
		[SerializeField, Tooltip("If the rotation of this projectile impacts its movement.")] private bool _rotationMatter;
		[SerializeField, Tooltip("If this projectile will instantiate another ones in an amount of quantity.")] private bool _useQuantity;
		[SerializeField, Tooltip("If this projectile will instantiate another after its death.")] private bool _inDeath;
		[SerializeField, Tooltip("If this projectile won't cause any type of damage.")] private bool _isInoffensive;
		[SerializeField, Tooltip("The vitality of this projectile.")] private ushort _vitality;
		[SerializeField, Tooltip("The amount of damage this projectile will cause to a target.")] private ushort _damage;
		[SerializeField, Tooltip("The amount of second projectiles to instantiate.")] private ushort _quantityToSummon;
		[SerializeField, Tooltip("The amount of speed this projectile will move.")] private float _movementSpeed;
		[SerializeField, Tooltip("The amount of speed the rotation spins.")] private float _rotationSpeed;
		[SerializeField, Tooltip("The angle the second projectile will be instantiated.")] private float _baseAngle;
		[SerializeField, Tooltip("The angle the second projectile have to be spreaded")] private float _spreadAngle;
		[SerializeField, Tooltip("The amount of time this projectile will stun.")] private float _stunTime;
		[SerializeField, Tooltip("The amount of time this projectile will exists after fade away.")] private float _timeToFade;
		[Header("Cell Projectile Statistics")]
		[SerializeField, Tooltip("If the second projectile will be instantiated in a cell.")] private bool _inCell;
		[SerializeField, Tooltip("If the second projectile will instantiate in a continuos sequence.")] private bool _continuosSummon;
		[SerializeField, Tooltip("If the instantiation of the second projectile will break after a moment.")] private bool _useBreak;
		[SerializeField, Tooltip("If the instantiation of the second projectile will always break after the first.")] private bool _alwaysBreak;
		[SerializeField, Tooltip("If the points of break are randomized between the maximum and minimum.")] private bool _randomBreak;
		[SerializeField, Tooltip("If the break point is restricted at a specific break point.")] private bool _extrictRandom;
		[SerializeField, Tooltip("The amount of cell points to jump the instantiation.")] private ushort _jumpPoints;
		[SerializeField, Tooltip("The exact point where the break of the instantiantion start.")] private ushort _breakPoint;
		[SerializeField, Tooltip("The exact point where the instantiation returns.")] private ushort _returnPoint;
		[SerializeField, Tooltip("The minimum value the break point can break.")] private ushort _minimumRandomValue;
		[SerializeField, Tooltip("The distance of the range ray to the instantiation.")] private float _distanceRay;
		internal EnemyPhysics Physics => _physics;
		internal EnemyProjectile SecondProjectile => _secondProjectile;
		internal EnemyController EnemyOnDeath => _enemyOnDeath;
		internal ForceMode2D ForceMode => _forceMode;
		internal bool UseForce => _useForce;
		internal bool StayInPlace => _stayInPlace;
		internal bool EndlessPursue => _endlessPursue;
		internal bool ParabolicMovement => _parabolicMovement;
		internal bool SideMovement => _sideMovement;
		internal bool InvertSide => _invertSide;
		internal bool UseSelfRotation => _useSelfRotation;
		internal bool RotationMatter => _rotationMatter;
		internal bool UseQuantity => _useQuantity;
		internal bool InDeath => _inDeath;
		internal bool IsInoffensive => _isInoffensive;
		internal ushort Vitality => _vitality;
		internal ushort Damage => _damage;
		internal ushort QuantityToSummon => _quantityToSummon;
		internal float MovementSpeed => _movementSpeed;
		internal float RotationSpeed => _rotationSpeed;
		internal float BaseAngle => _baseAngle;
		internal float SpreadAngle => _spreadAngle;
		internal float StunTime => _stunTime;
		internal float TimeToFade => _timeToFade;
		internal bool InCell => _inCell;
		internal bool ContinuosSummon => _continuosSummon;
		internal bool UseBreak => _useBreak;
		internal bool AlwaysBreak => _alwaysBreak;
		internal bool RandomBreak => _randomBreak;
		internal bool ExtrictRandom => _extrictRandom;
		internal ushort JumpPoints => _jumpPoints;
		internal ushort BreakPoint => _breakPoint;
		internal ushort ReturnPoint => _returnPoint;
		internal ushort MinimumRandomValue => _minimumRandomValue;
		internal float DistanceRay => _distanceRay;
	};
};
